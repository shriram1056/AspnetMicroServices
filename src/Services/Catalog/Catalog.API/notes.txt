STRUCTURE:

settings related to url and launch are in Properties/launchSettings.json

add package by right clicking Depenencies and selecting "Add nuget"

get values in appsettings.json by configuration.GetValue<string>("DatabaseSettings:DatabaseName")



PACKAGES:

MongoDB.Driver

Microsoft.VisualStudio.Azure.Containers.Tools.Targets // adds automatically when container support enabled



MONGODB:

right click "solution" and click "open in terminal"

docker pull mongo

docker run -d -p 27017:27017 --name shopping-mongo mongo		// -d create a container and continue using the terminal or shell without being attached to the container's console.

docker run -d -p 3000:3000 mongoclient/mongoclient  // for debugging in mongo db in UI

docker run -d -p local_port:image_port

docker ps								// list all running container

docker logs -f shopping-mongo

docker exec -it shopping-mongo command		//  this runs a single command inside the container. each container is a seperate os with linux file system. -i is for providing inputs to the shell in container. -t is emulating a terminal functionalities. 

docker exec -it shopping-mongo /bin/bash	// run the bash executable in /bin to open terminal

mongosh			// goes to mongo-cli

show dbs/databases		// list dbs

show collections		// show collections in the current Db

use database			// switch to this database

db.createCollection('Products')  // create Products collection

db.Products.insertMany([{ 'Name':'Asus Laptop','Category':'Computers', 'Summary':'Summary', 'Description':'Description', 'ImageFile':'ImageFile', 'Price':54.93 }, { 'Name':'HP Laptop','Category':'Computers', 'Summary':'Summary', 'Description':'Description', 'ImageFile':'ImageFile', 'Price':88.93 } ])

db.Products.find({}).pretty()    // find all with no filter and display in json format

db.Products.remove({})			// remove all

[BsonId]    // the field is Id field

[BsonRepresentation(BsonType.ObjectId)]   // generate r value on insert

[BsonElement("Name")]     // name of field in MONGO




CONTROLLER:

The [controller] token in the [Route] attribute gets the name of the class by convention-based routing in ASP.NET. When the attribute is applied to a controller class, ASP.NET automatically replaces [controller] with the name of the controller class, but with the "Controller" suffix removed.

By specifying ILogger<CatalogController>, you are indicating that you want to inject an instance of a logger specifically for the CatalogController class.

ActionResult is a base class for the return types of action methods. we use it in the controller to represent the result of an action method execution and encapsulates the data that will be sent back as the HTTP response from the server to the client.

Using ProducesResponseType attribute with typeof(IEnumerable<Product>) provides documentation for the consumers of your API, informing them about the expected response type. 

IEnumerable<Product> is a compile-time construct used for type checking, variable declarations, method signatures, and other static aspects of your code.

By using the typeof operator, we get a Type object containing metadata and information about the type at runtime.

Name attribute in HttpMethod specifies the name of the route. By providing a name, you can refer to this specific route by name elsewhere in your code. For example, it can be useful when generating URLs or performing route-based operations.

If there are multiple http methods then Routes need to be used to specify multiple endpoints.

The [FromBody] is only needed if you're doing an MVC controller. The FromBody attribute is used to bind data from the request body to action method parameters. normally, for post request the data is sent through the body.





PROGRAM.cs:

When a service is registered with the AddScoped method, a new instance of that service is created once per client request within the scope. 




C#:

A nameof function produces the name of a variable, type, or member as the string constant



DOCKER:

https://stackoverflow.com/questions/53332539/why-do-we-build-and-publish-as-two-steps-when-publish-also-builds

1. command to create and run the container?

docker-compose -f docker-compose.yml -f docker-compose.override.yml up -d

-f: flag to specify the location of a Compose configuration file.

up: command starts the services defined in the Compose files.

-d: This option runs the containers in detached mode, which means they will run in the background and won't occupy the console.


2. command to stop and remove the container?

docker-compose -f docker-compose.yml -f docker-compose.override.yml down

used to stop and remove the containers defined in the Docker Compose configuration files.


3. how to build a docker image?

docker build -t aspnetapp . 

builds a Docker image with the name "aspnetapp" using the Dockerfile and other required files present in the current directory.


4. how to add containerization support""

right click Catalog.API and select Add> "containerization orchestration support" to get auto-generated docker file and compose. 

set everything to "false" except for remove in tool > docker compose for faster build


5. how does selecting docker-compose profile change managing the code base?

when you build or clean the solution while the "docker-compose" profile selected, then the docker containers will built or cleaned 


6. how can i you set breakpoints and debug code once the code runs in the container?

we can set breakpoints to debug things, when we run the app in "Debug" mode

if you select docker-compose profile and click run, then there will a container tab and output > Debug for build details.

Debug: The Debug configuration is intended for development and testing purposes. It includes additional debugging information in the compiled code, such as symbols and metadata, to facilitate debugging and enable features like breakpoints, stepping through code, and inspecting variables. It typically has optimizations disabled to make the debugging experience easier. when in "Debug" mode, the .net image with dev tag is used

Release: The Release configuration is optimized for the final deployment of the software. It is focused on generating a smaller and faster executable file by enabling various compiler optimizations. Debugging information is usually stripped from the compiled code to reduce its size and improve performance. when in "Release" mode, the .net image with latest tag is used


logs for the container are in container tab


7. how is visual studio able to debug built code?

Here's an overview of how Visual Studio is able to debug built code:

Debug Symbols (PDB Files): During the build process, Visual Studio generates Debug symbols, also known as Program Database (PDB) files. These files contain additional information about the compiled code, such as function names, variable names, and line number mappings.

Just-In-Time (JIT) Debugging: Visual Studio uses Just-In-Time (JIT) debugging to attach to a running process when debugging built code.


8. why can't you connect to mongodb in docker?

use __ to show nesting in docker compose for connection string instead of :, it seems like : can only be used in windows and the container is linux.


9. does .NET automatically convert .Net Object to JSON?

when working with MongoDB and the .NET driver, the driver automatically handles the conversion between .NET objects and BSON (Binary JSON), which is the native data format used by MongoDB.


10. does Mongo Db automatically convert .Net Object to BSON?

when working with MongoDB and the .NET driver, the driver automatically handles the conversion between .NET objects and BSON (Binary JSON), which is the native data format used by MongoDB.