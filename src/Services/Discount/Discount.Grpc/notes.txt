 remove HTTPS and modify HTTP:

	right click solution, select properties, go to debug section, remove the https URL and modify http URL of launch profiles.



Network latency is the amount of time it takes for a data packet to go from one place to another.

most communication in backend is asynchronous and some calls are synchronous and GRPC should be used for such communication. 

gRPC (Google Remote Procedure Call) is an open-source high-performance framework developed by Google for building distributed systems. It enables communication between services across different languages and platforms by using a language-agnostic, platform-neutral protocol called Protocol Buffers (protobuf) for data serialization.

In microservices architecture, where applications are split into small, independently deployable services, communication between these services becomes crucial. Traditional approaches like using RESTful APIs or message queues have certain limitations, such as higher latency, overhead in data serialization/deserialization, and lack of strong typing. gRPC addresses these challenges by providing the following benefits:

synchronous backend communication: gRPC uses HTTP/2, a modern transport protocol that supports bidirectional streaming, multiplexing, and header compression. This allows for efficient communication between services with lower latency and reduced network overhead.

Strong Typing: With gRPC, you define your service interfaces using Protocol Buffers, which is a language-agnostic interface definition language (IDL).

Code Generation: gRPC leverages Protocol Buffers to generate client and server code in various programming languages. This code generation simplifies service integration by providing a convenient API that abstracts away the underlying network communication. Clients can make remote procedure calls to services as if they were local function invocations.

Bi-directional Streaming

GRPC message are smaller than JSON



grpc stub classes:

 the "gRPC stub classes" refer to the client-side code that is generated from the .proto file when using the gRPC framework. These stub classes encapsulate the network communication and serialization/deserialization logic necessary to communicate with the gRPC server.



greet.proto:

	a Protocol Buffers (protobuf) file, the gRPC service "Greeter" is defined using the protobuf syntax. It has one RPC (Remote Procedure Call) method called "SayHello", which takes an input message of type "HelloRequest" and returns a response message of type "HelloReply". Both "HelloRequest" and "HelloReply" are also defined as message types in the protobuf file.

	right click greet.proto and select properties, we can select what code should be generated in "grpc stub class" field:

	Generate client code: This option allows you to control whether the client-side code should be generated. If enabled, the gRPC stub classes will be generated.

	Generate server code: Similarly, this option controls the generation of server-side code if you have defined gRPC services on the server.




GreeterService.cs:

	the gRPC service implementation for the "Greeter" service is provided. The class "GreeterService" extends the generated base class "Greeter.GreeterBase" (which is generated from the protobuf definition) and overrides the "SayHello" method. Inside the overridden method, it creates a new instance of the "HelloReply" message and sets its "Message" property to "Hello" concatenated with the name received in the "HelloRequest" message. The implementation uses the provided logger to log information.


GreeterBase:

is the server code of the grpc, that we can use to implement grpc methods



Program.cs:

	UseEndpoints method is used to map the GreeterService (which is the implementation class from your first file) as a gRPC service endpoint.

	AddGrpc adds services to the container, dependencies and middlewares



Discount.Grpc.csproj:

	you can change if the Grpc Service is client or server



